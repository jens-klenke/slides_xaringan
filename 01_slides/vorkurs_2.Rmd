---
title: "R Vorkurs"
subtitle: "Teil 2"
author: "Martin Arnold & Jens Klenke"
date: "28.10 - 30.10.2020"
output:
  xaringan::moon_reader:
    css: ["default", "assets/sydney-fonts.css", "assets/sydney.css"]
    self_contained: true # if true, fonts will be stored locally
    seal: true # show a title slide with YAML information
    includes:
      in_header: "assets/mathjax-equation-numbers.html"
    nature:
      beforeInit: ["assets/remark-zoom.js", "https://platform.twitter.com/widgets.js"]
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      ratio: '16:9' #alternatives '16:9' or '4:3' or others e.g. 13:9
      navigation:
        scroll: true #disable slide transitions by scrolling
---
class: inverse
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = T, small = T)

options(htmltools.dir.version = FALSE)
options(servr.daemon = TRUE)
options(servr.interval = 0.5)

#xaringan::inf_mr()

#### required packages ####
# packages
suppressWarnings(source(here::here('00_packages/packages.R')))
```


```{r, load_refs, echo=FALSE, cache=FALSE, warning = FALSE, message = TRUE}
library(RefManageR)
BibOptions(check.entries = FALSE, 
           bib.style = "authoryear", 
           cite.style = 'authoryear', 
           style = "markdown",
           hyperlink = FALSE, 
           dashed = FALSE)
myBib <- ReadBib("assets/example.bib", check = FALSE)

```

# Überischt 

<br></br>

1. Logische Operatoren
2. Dataframes
3. Listen
4. Bedingte Anweisungen
5. Schleifen
6. Funktionen
7. <code>R</code> Pakete

---
# Logische Operatoren
## Einführung

Die Klasse `logical` habt ihr im ersten Teil schon mal gesehen (`is.na()`)

Logische Vergleiche werden für das Programmieren bedingter Anweisungen benötigt. Sie kommen aber auch häufig bei Schleifen und beim Subsetten von Daten zum Einsatz.

Das Ergebnis logischer Vergleiche ist immer ein *boolscher Wert*, also `TRUE` / `FALSE` bzw. `T ` / `F `.

Die wichtigsten Operatoren im Überblick:
```{r, eval = FALSE}
  ==  # "ist gleich"
  !=  # "ist ungleich"
  <   # "ist kleiner"
  <=  # "ist kleiner oder gleich"
  >   # "ist größer"
  >=  # "ist größer gleich"
  &   # "logisches 'Und'"
  |   # "logisches 'Oder'"
  !   # einen boolschen Wert "negieren"
```

---
# Logische Operatoren
## Beispiele

Hier ein paar Beispiele:

```{r, echo = F, eval = T}
# x <- 5
# y <- 10
```

```{r, eval = FALSE}
x <- 5
y <- 10

x == y
x > y | y == 10
x > y | x == 10
!(x == y | y < x)
((y == 9 | T) & (x > y | T))
!T & !F
```

```{r, fig_dens_2, echo = FALSE, out.width = '50%',  fig.align = "center"}
   knitr::include_graphics(here::here('01_slides/Untitled.png'), auto_pdf = FALSE)
```

---
# Logische Operatoren
## Übungsaufgaben --- 1 

1. Sind die folgenden Ausdrücke `TRUE` oder `FALSE`?
- $5 \geq 5$
- $5 > 5$
- $T = 5$
- $T \land F \ \lor \ F \land T$
- $F \land F \land F\ \lor \ T$
- $( \neg (5 > 3) \lor A = B)$
- $\neg(((T > F) > T) \land \ \neg T$

---
# Logische Operatoren
## Übungsaufgaben --- 2

<ol start = "2">
    <li>Es sei `z <- c(1, 2, NA, 4)`. Überprüfen Sie die folgenden Aussagen mittels einer Logikabfrage in `R`.</li>
</ol>

- Die Länge des Vektors $z$ ist ungleich $2$.
- Die Länge der logischen Überprüfungen, ob die einzenlen Elementen gleich $2$ sind, ist $4$.
- Der Vektor $z$ hat die Klasse `numeric`.
- Einige Elemente des Vektors $z$ sind `NA`. 
- Das Zweite Element des Vektors $z$ ist `numeric`
- Das Minimum und das Maximum sind ungleich. 

---
# Logische Operatoren
## Übungsaufgaben  --- 3


<ol start = "3">
    <li> Es sei `M <- matrix(1:9, ncol = 3)`. Was ergeben folgende Ausdrücke: </li>
</ol>

- sum$(M[ , 1]) == 6$
- max$(M[ , 2]) <= 5$
- $M[2, 2] != 4 \ \& \ M[2, 2] > 6$

---
# Dataframes
## Über Dataframes

Ein dataframe ist eine Sammlung von Variablen, ähnlich einer Matrix. 

Am Beispiel des Datensatzes `iris`:

```{r, eval = T}
iris[1:10, ]
```

---
# Dataframes 
## Über Dataframes

Die Funktion `str()` liefert Informationen über die Struktur eines Objekts:

```{r, eval = T}
str(iris)
```

Wir sehen:

- das Objekt `iris` hat die Klasse `data.frame`
- `iris` hat 150 Zeilen (Beobachtungen) und 5 Spalten (Variablen).
- Vier der Variablen gehören zur Klasse `numeric`, 1 Variable zur Klasse `Factor`

---
# Dataframes 
## Erstellen von dataframes

Ein dataframe wird mit der Funktion `data.frame()` erstellt. Hierzu übergeben wir einfach Vektoren, welche als Spalten gruppiert werden sollen. Spalten können benannt werden.

Anders als bei Matrizen müssen die einzelnen Spalten (wie oben gesehen) nicht derselben Klasse angehören!

```{r include = FALSE}
z <- c(1, 2, NA, 4)
```

```{r, eval = T}
df <- data.frame(Letters = c("A", "B", "C", "D"), 
                 Numbers = 1:4,
                 Logicals = c(T, F, FALSE, TRUE),
                 z)
df
```

---
## Zugriff auf Spalten und Elemente

Auf die einzelnen Zellen in einem dataframe kann man wie bei Matrizen durch Indexierung mit `[ ]` zugreifen. Zugriff auf einzelne Variablen/Spalten erhält man mit `$`:

.font80[
```{r}
df[ , 1]       # Spalte 1
df[1, ]        # Zeile 1
df[1, 1]       # Zeile 1, Spalte 1
df[ , 1:2]     # Spalten 1 und 2
```
]

---
# Dataframes 
## Zugriff auf Spalten und Elemente

.font80[
```{r}
df$Numbers     # Spalte/Variable "Numbers"
```
]

Subsetting:

.font80[
```{r}
df[df$Letters == "B", ]
df[df$Numbers > 2, ]
```
]

---
# Dataframes 
## Bearbeiten von dataframes
<br></br>
Ein dataframe ist nach seiner Erstellung nicht unveränderbar. Man kann Spalten und Zeilen hinzufügen oder entfernen. Das gilt auch für einzelne Beobachtungen.

```{r, eval = T}
df$Greeks <- c("alpha", "beta", "gamma", "delta")   # Hinzufügen einer Spalte "Greeks"
df        <- df[-2, ]                               # Entfernen der zweiten Zeile
df[2, 2]  <- NA                                     # Beobachtung an Stelle 3x2 auf NA setzen
df
```

---
# Dataframes 
## Übungsaufgaben

<ol start = "4">
    <li>Verschaffen Sie sich einen Überblick über den Datensatz `mtcars` (dieser ist in base R bereits geladen)</li>
    <ul>
      <li>Aus wieviele Variablen besteht er? Welche Klasse haben die einzelnen Variablen?</li>
    </ul>
    <li>Lassen Sie sich folgende Subsets von `mtcars` ausgeben:</li>
    <ul>
      <li>nur die Variable `mpg`</li>
      <li>nur die ersten drei Zeilen</li>
      <li>nur die ersten drei Variablen</li>
      <li>nur die ersten beiden Beobachtungen der Variablen `cyl` und `hp`</li>
      <li>alle Beobachtungen deren Ausprägung der Variablen `hp` größer ist als 200</li>
    </ul>
</ol>


---
# Dataframes 
## Übungsaufgaben

<ol start = "6">
    <li>Erstellen Sie einen dataframe `persons` mit den Variablen <code>Name</code> (<code>character</code>), <code>Height</code> (cm, <code>numeric</code>) und <code>Weight</code> (kg, <code>numeric</code>) von 5 fiktiven Personen.</li>
    <ul>
      <li>Lassen Sie sich das Körpergewicht der 3. Person anzeigen.</li>
      <li>Lassen Sie sich nun die Körpergröße aller Personen anzeigen.</li>
      <li>Fügen Sie die Variable "Augenfarbe" hinzu. Die Ausprägungen sollten vom Typ <code>character</code> sein. Schauen Sie sich den veränderten dataframe an.</li>
    </ul>
</ol>

---
# Listen
## Listen erzeugen

Listen werden mit der Funktion `list()` erzeugt. Ein \hil{Vorteil} von Listen ist, dass die einzelnen Elemente von unterschiedlicher Größe und Typ sein können.

Der Zugriff auf Listenelemente erfolgt ebenfalls mit `$`:

```{r, eval = FALSE}
my.list <- list(A = 1:5, B = mtcars, C = list(letters, LETTERS))
```

Viele Funktionen in R geben Ergebnisse als Listen zurück.


```{r, eval = FALSE}
# Regressionsmodell
model <- lm(mpg ~ hp, data = mtcars)
str(model)
model$coefficients
model$residuals
```


(Mehr dazu in Teil 3)

---
# Bedingte Anweisungen
## If-Anweisung

Bedingte Anweisungen helfen uns den Programmablauf zu steuern. Die einfachste Anweisung ist die `if`-Anweisung:

```{r, eval = FALSE}
if (x == 5) print("Hallo Welt!")
```

Dies kann man lesen wie eine natürliche Sprache:

.center[ .blue[<em>FALLS</em>] `x` gleich 5 ist, .blue[<em>DANN</em>] gebe "Hallo Welt!" aus.]

Die Bedingung muss immer zu `TRUE` oder `FALSE` evaluieren. Nur wenn der Ausdruck in den Klammern nach <em>if</em> wahr ist, wird der nachfolgende Code ausgeführt.


---
## If-Anweisung

Wenn der auszuführende Code länger als eine Zeile ist, nutzt man *geschweifte Klammern* um einen Code-Block zu erzeugen:

.font80[
```{r, eval = FALSE}
if (x > 0) {
  # Code
  # ...
}
```
]

Ein paar Beispiele:

.font80[
```{r, eval = FALSE}
if ( class(x) == "numeric" ) print("x ist eine Zahl!")
# FALLS die Klasse von x "numeric" ist, DANN gebe "x ist eine Zahl!" aus.

if (2 * x >= y) print("Die Hälfte von y ist x!")
# FALLS 2*x größer oder gleich y ist, DANN gebe "Die Hälfte von y ist x!" aus.

z  <- 1:10
op <- "add"

if (length(z) > 1 & op == "add") {
  sum(z)
}
# FALLS die Länge des Vektors z größer als 1 ist UND op GLEICH "add" ist, 
# DANN  summiere die Elemente von z.
```
]

---
# Bedingte Anweisungen
## If-Else Anweisung
<br></br>
Wenn der Ausdruck innerhalb der Klammern nicht `TRUE` ist, wird der Codeblock nicht ausgeführt.

Aber was wäre wenn wir in diesem Fall einen anderen Code ausführen wollen?

.blue[<b>Lösung</b>]: die `If-Else`-Anweisung

```{r, eval = F}
if (expr) {    # Wenn "expr" TRUE ist, ...
  # BLOCK 1    # dann führe BLOCK 1 aus.
} else {       # Wenn "expr" FALSE ist, ...
  # BLOCK 2    # dann führe BLOCK 2 aus.
}
```

---
# Bedingte Anweisungen
## If-Else Anweisung

<br></br>
Auch hier Beispiele:

.font80[
```{r , eval = FALSE}
if (is.numeric(x) & x >= 0) {
  x^(-0.5)
} else {
  print("x ist keine Zahl oder negativ!")
}

if(length(z) > 0 & op == "add") {
  sum(z)
} else if(length(z) > 0 & op == "mult") {
  prod(z)
} else {
  print("z ist kein Vektor!")
}
```
]

---
# Bedingte Anweisunge
## If-Else(-If) Anweisung
<br></br>

Wie im letzten Beispiel gesehen kann man beliebig viele Bedingungen mit `If` und `Else` verknüpfen.

```{r, eval = FALSE}
if (expression) {
  # ...
} else if(expression) {
  # ...  
} else if(expression) {
  # ...  
} else {
  # ...  
}
```

---
# Bedingte Anweisunge
## Übungsaufgaben

<ol start = "7">
    <li>Schreibe Code, der die Wurzel (\(sqrt()\)) eines Vektors `x` der Länge 1 berechnet, wenn der Wert in `x` nicht negativ ist.</li>
    <li>Erstelle Code, welcher die Wurzel der Elemente eines Vektors `x` berechnet, wenn alle Werte in `x` nicht negativ sind.</li>
    <ul>
      <li><i>Hinweis:</i> nutze eine Funktion wie \(\text{min}()\) oder \(\text{sum}()\)</li>
    </ul>
    <li>Schreibe Code, der die Struktur (\( \text{str()}\)) eines Objekts \(\text{df}\) wiedergibt, sofern \(\text{df}\) zur Klasse \(\text{data.frame}\) gehört. Andernfalls soll die Länge des Objekts wiedergegeben werden.</li>
    <ul>
      <li><i>Überprüft eure Codes in dem ihre verschiedene Werte für \(\text{x}\) bzw. \(\text{df}\) ausprobiert!</i></li>
    </ul>
</ol>

---
# Schleifen
## for-Schleife

Es gibt drei Schleifentypen in R: `for`, `while` (und `repeat`)

Die `for`-Schleife hat folgenden Aufbau:
```{r, eval = F}
for(var in enumeration) {
  # Schleifenkörper
}
```
Für jeden Wert in .blue[<code>enumeration</code>] wird der Schleifenkörper einmal ausgeführt. Bei jedem Durchgang ist der aktuelle Wert aus .blue[<code>enumeration</code>] in .blue[<code>var</code>] zwischengespeichert.


```{r, eval = F}
for(i in 1:5) {
  cat("Number: ", i, " ", "\n")
}
```





