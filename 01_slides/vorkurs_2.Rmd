---
title: "R Vorkurs"
subtitle: "Teil 2"
author: "Martin Arnold & Jens Klenke"
date: "28.10 - 30.10.2020"
output:
  xaringan::moon_reader:
    css: ["default", "assets/sydney-fonts.css", "assets/sydney.css"]
    self_contained: true # if true, fonts will be stored locally
    seal: true # show a title slide with YAML information
    includes:
      in_header: "assets/mathjax-equation-numbers.html"
    nature:
      beforeInit: ["assets/remark-zoom.js", "https://platform.twitter.com/widgets.js"]
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      ratio: '16:9' #alternatives '16:9' or '4:3' or others e.g. 13:9
      navigation:
        scroll: true #disable slide transitions by scrolling
---
class: inverse
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = T, small = T)

options(htmltools.dir.version = FALSE)
options(servr.daemon = TRUE)
options(servr.interval = 0.5)

#xaringan::inf_mr()

#### required packages ####
# packages
suppressWarnings(source(here::here('00_packages/packages.R')))
```


```{r, load_refs, echo=FALSE, cache=FALSE, warning = FALSE, message = TRUE}
library(RefManageR)
BibOptions(check.entries = FALSE, 
           bib.style = "authoryear", 
           cite.style = 'authoryear', 
           style = "markdown",
           hyperlink = FALSE, 
           dashed = FALSE)
myBib <- ReadBib("assets/example.bib", check = FALSE)

```

# Überischt 

<br></br>

1. Logische Operatoren
2. Dataframes
3. Listen
4. Bedingte Anweisungen
5. Schleifen
6. Funktionen
7. <code>R</code> Pakete

---
## Logische Operatoren
### Einführung

Die Klasse `logical` habt ihr im ersten Teil schon mal gesehen (`is.na()`)

Logische Vergleiche werden für das Programmieren bedingter Anweisungen benötigt. Sie kommen aber auch häufig bei Schleifen und beim Subsetten von Daten zum Einsatz.

Das Ergebnis logischer Vergleiche ist immer ein *boolscher Wert*, also `TRUE` / `FALSE` bzw. `T ` / `F `.

Die wichtigsten Operatoren im Überblick:
```{r, eval = FALSE}
  ==  # "ist gleich"
  !=  # "ist ungleich"
  <   # "ist kleiner"
  <=  # "ist kleiner oder gleich"
  >   # "ist größer"
  >=  # "ist größer gleich"
  &   # "logisches 'Und'"
  |   # "logisches 'Oder'"
  !   # einen boolschen Wert "negieren"
```

---
## Logische Operatoren
### Beispiele

Hier ein paar Beispiele:

```{r, echo = F, eval = T}
# x <- 5
# y <- 10
```

```{r, eval = FALSE}
x <- 5
y <- 10

x == y
x > y | y == 10
x > y | x == 10
!(x == y | y < x)
((y == 9 | T) & (x > y | T))
!T & !F
```

```{r, fig_dens_2, echo = FALSE, out.width = '50%',  fig.align = "center"}
   knitr::include_graphics(here::here('01_slides/Untitled.png'), auto_pdf = FALSE)
```

---
## Logische Operatoren
### Übungsaufgaben --- 1 

1. Sind die folgenden Ausdrücke `TRUE` oder `FALSE`?
- $5 \geq 5$
- $5 > 5$
- $T = 5$
- $T \land F \ \lor \ F \land T$
- $F \land F \land F\ \lor \ T$
- $( \neg (5 > 3) \lor A = B)$
- $\neg(((T > F) > T) \land \ \neg T$

---
## Logische Operatoren
### Übungsaufgaben --- 2

<ol start = "2">
    <li>Es sei `z <- c(1, 2, NA, 4)`. Überprüfen Sie die folgenden Aussagen mittels einer Logikabfrage in `R`.</li>
</ol>

- Die Länge des Vektors $z$ ist ungleich $2$.
- Die Länge der logischen Überprüfungen, ob die einzenlen Elementen gleich $2$ sind, ist $4$.
- Der Vektor $z$ hat die Klasse `numeric`.
- Einige Elemente des Vektors $z$ sind `NA`. 
- Das Zweite Element des Vektors $z$ ist `numeric`
- Das Minimum und das Maximum sind ungleich. 

---
## Logische Operatoren
### Übungsaufgaben  --- 3


<ol start = "3">
    <li> Es sei `M <- matrix(1:9, ncol = 3)`. Was ergeben folgende Ausdrücke: </li>
</ol>

- sum$(M[ , 1]) == 6$
- max$(M[ , 2]) <= 5$
- $M[2, 2] != 4 \ \& \ M[2, 2] > 6$

---
## Dataframes
### Über Dataframes

Ein dataframe ist eine Sammlung von Variablen, ähnlich einer Matrix. 

Am Beispiel des Datensatzes `iris`:

```{r, eval = T}
iris[1:10, ]
```

---
## Dataframes 
### Über Dataframes

Die Funktion `str()` liefert Informationen über die Struktur eines Objekts:

```{r, eval = T}
str(iris)
```

Wir sehen:

- das Objekt `iris` hat die Klasse `data.frame`
- `iris` hat 150 Zeilen (Beobachtungen) und 5 Spalten (Variablen).
- Vier der Variablen gehören zur Klasse `numeric`, 1 Variable zur Klasse `Factor`

---
## Dataframes 
### Erstellen von dataframes

Ein dataframe wird mit der Funktion `data.frame()` erstellt. Hierzu übergeben wir einfach Vektoren, welche als Spalten gruppiert werden sollen. Spalten können benannt werden.

Anders als bei Matrizen müssen die einzelnen Spalten (wie oben gesehen) nicht derselben Klasse angehören!

```{r include = FALSE}
z <- c(1, 2, NA, 4)
```

```{r, eval = T}
df <- data.frame(Letters = c("A", "B", "C", "D"), 
                 Numbers = 1:4,
                 Logicals = c(T, F, FALSE, TRUE),
                 z)
df
```

---
### Zugriff auf Spalten und Elemente

Auf die einzelnen Zellen in einem dataframe kann man wie bei Matrizen durch Indexierung mit `[ ]` zugreifen. Zugriff auf einzelne Variablen/Spalten erhält man mit `$`:

.font80[
```{r}
df[ , 1]       # Spalte 1
df[1, ]        # Zeile 1
df[1, 1]       # Zeile 1, Spalte 1
df[ , 1:2]     # Spalten 1 und 2
```
]

---
## Dataframes 
### Zugriff auf Spalten und Elemente

.font80[
```{r}
df$Numbers     # Spalte/Variable "Numbers"
```
]

Subsetting:

.font80[
```{r}
df[df$Letters == "B", ]
df[df$Numbers > 2, ]
```
]

---
## Dataframes 
### Bearbeiten von dataframes
<br></br>
Ein dataframe ist nach seiner Erstellung nicht unveränderbar. Man kann Spalten und Zeilen hinzufügen oder entfernen. Das gilt auch für einzelne Beobachtungen.

```{r, eval = T}
df$Greeks <- c("alpha", "beta", "gamma", "delta")   # Hinzufügen einer Spalte "Greeks"
df        <- df[-2, ]                               # Entfernen der zweiten Zeile
df[2, 2]  <- NA                                     # Beobachtung an Stelle 3x2 auf NA setzen
df
```

---
## Dataframes 
### Übungsaufgaben

<ol start = "4">
    <li>Verschaffen Sie sich einen Überblick über den Datensatz `mtcars` (dieser ist in base R bereits geladen)</li>
    <ul>
      <li>Aus wieviele Variablen besteht er? Welche Klasse haben die einzelnen Variablen?</li>
    </ul>
    <li>Lassen Sie sich folgende Subsets von `mtcars` ausgeben:</li>
    <ul>
      <li>nur die Variable `mpg`</li>
      <li>nur die ersten drei Zeilen</li>
      <li>nur die ersten drei Variablen</li>
      <li>nur die ersten beiden Beobachtungen der Variablen `cyl` und `hp`</li>
      <li>alle Beobachtungen deren Ausprägung der Variablen `hp` größer ist als 200</li>
    </ul>
</ol>


---
## Dataframes 
### Übungsaufgaben

<ol start = "6">
    <li>Erstellen Sie einen dataframe `persons` mit den Variablen <code>Name</code> (<code>character</code>), <code>Height</code> (cm, <code>numeric</code>) und <code>Weight</code> (kg, <code>numeric</code>) von 5 fiktiven Personen.</li>
    <ul>
      <li>Lassen Sie sich das Körpergewicht der 3. Person anzeigen.</li>
      <li>Lassen Sie sich nun die Körpergröße aller Personen anzeigen.</li>
      <li>Fügen Sie die Variable "Augenfarbe" hinzu. Die Ausprägungen sollten vom Typ <code>character</code> sein. Schauen Sie sich den veränderten dataframe an.</li>
    </ul>
</ol>

---
## Listen
### Listen erzeugen

Listen werden mit der Funktion `list()` erzeugt. Ein \hil{Vorteil} von Listen ist, dass die einzelnen Elemente von unterschiedlicher Größe und Typ sein können.

Der Zugriff auf Listenelemente erfolgt ebenfalls mit `$`:

```{r, eval = FALSE}
my.list <- list(A = 1:5, B = mtcars, C = list(letters, LETTERS))
```

Viele Funktionen in R geben Ergebnisse als Listen zurück.


```{r, eval = FALSE}
# Regressionsmodell
model <- lm(mpg ~ hp, data = mtcars)
str(model)
model$coefficients
model$residuals
```


(Mehr dazu in Teil 3)

---
## Bedingte Anweisungen
### If-Anweisung

Bedingte Anweisungen helfen uns den Programmablauf zu steuern. Die einfachste Anweisung ist die `if`-Anweisung:

```{r, eval = FALSE}
if (x == 5) print("Hallo Welt!")
```

Dies kann man lesen wie eine natürliche Sprache:

.center[ .blue[<em>FALLS</em>] `x` gleich 5 ist, .blue[<em>DANN</em>] gebe "Hallo Welt!" aus.]

Die Bedingung muss immer zu `TRUE` oder `FALSE` evaluieren. Nur wenn der Ausdruck in den Klammern nach <em>if</em> wahr ist, wird der nachfolgende Code ausgeführt.


---
### If-Anweisung

Wenn der auszuführende Code länger als eine Zeile ist, nutzt man *geschweifte Klammern* um einen Code-Block zu erzeugen:

.font80[
```{r, eval = FALSE}
if (x > 0) {
  # Code
  # ...
}
```
]

Ein paar Beispiele:

.font80[
```{r, eval = FALSE}
if ( class(x) == "numeric" ) print("x ist eine Zahl!")
# FALLS die Klasse von x "numeric" ist, DANN gebe "x ist eine Zahl!" aus.

if (2 * x >= y) print("Die Hälfte von y ist x!")
# FALLS 2*x größer oder gleich y ist, DANN gebe "Die Hälfte von y ist x!" aus.

z  <- 1:10
op <- "add"

if (length(z) > 1 & op == "add") {
  sum(z)
}
# FALLS die Länge des Vektors z größer als 1 ist UND op GLEICH "add" ist, 
# DANN  summiere die Elemente von z.
```
]

---
## Bedingte Anweisungen
### If-Else Anweisung
<br></br>
Wenn der Ausdruck innerhalb der Klammern nicht `TRUE` ist, wird der Codeblock nicht ausgeführt.

Aber was wäre wenn wir in diesem Fall einen anderen Code ausführen wollen?

.blue[<b>Lösung</b>]: die `If-Else`-Anweisung

```{r, eval = F}
if (expr) {    # Wenn "expr" TRUE ist, ...
  # BLOCK 1    # dann führe BLOCK 1 aus.
} else {       # Wenn "expr" FALSE ist, ...
  # BLOCK 2    # dann führe BLOCK 2 aus.
}
```

---
## Bedingte Anweisungen
### If-Else Anweisung

<br></br>
Auch hier Beispiele:

.font80[
```{r , eval = FALSE}
if (is.numeric(x) & x >= 0) {
  x^(-0.5)
} else {
  print("x ist keine Zahl oder negativ!")
}

if(length(z) > 0 & op == "add") {
  sum(z)
} else if(length(z) > 0 & op == "mult") {
  prod(z)
} else {
  print("z ist kein Vektor!")
}
```
]

---
## Bedingte Anweisunge
### If-Else(-If) Anweisung
<br></br>

Wie im letzten Beispiel gesehen kann man beliebig viele Bedingungen mit `If` und `Else` verknüpfen.

```{r, eval = FALSE}
if (expression) {
  # ...
} else if(expression) {
  # ...  
} else if(expression) {
  # ...  
} else {
  # ...  
}
```

---
## Bedingte Anweisunge
### Übungsaufgaben

<ol start = "7">
    <li>Schreibe Code, der die Wurzel (\(sqrt()\)) eines Vektors `x` der Länge 1 berechnet, wenn der Wert in `x` nicht negativ ist.</li>
    <li>Erstelle Code, welcher die Wurzel der Elemente eines Vektors `x` berechnet, wenn alle Werte in `x` nicht negativ sind.</li>
    <ul>
      <li><i>Hinweis:</i> nutze eine Funktion wie \(\text{min}()\) oder \(\text{sum}()\)</li>
    </ul>
    <li>Schreibe Code, der die Struktur (\( \text{str()}\)) eines Objekts \(\text{df}\) wiedergibt, sofern \(\text{df}\) zur Klasse \(\text{data.frame}\) gehört. Andernfalls soll die Länge des Objekts wiedergegeben werden.</li>
    <ul>
      <li><i>Überprüft eure Codes in dem ihre verschiedene Werte für \(\text{x}\) bzw. \(\text{df}\) ausprobiert!</i></li>
    </ul>
</ol>

---
## Schleifen
### for-Schleife

Es gibt drei Schleifentypen in R: `for`, `while` (und `repeat`)

Die `for`-Schleife hat folgenden Aufbau:
```{r, eval = F}
for(var in enumeration) {
  # Schleifenkörper
}
```
Für jeden Wert in .blue[<code>enumeration</code>] wird der Schleifenkörper einmal ausgeführt. Bei jedem Durchgang ist der aktuelle Wert aus .blue[<code>enumeration</code>] in .blue[<code>var</code>] zwischengespeichert.


```{r, eval = F}
for(i in 1:5) {
  cat("Number: ", i, " ", "\n")
}
```

---
## Schleifen
### while-Schleife

Die `while`-Schleife kann genutzt werden, wenn nicht klar ist, wie oft ein Codeabschnitt ausgeführt werden soll:

```{r, eval = F}
while(condition) {
  # Schleifenkörper
}
```

Solange .blue[<code>ondition</code>] wahr ist, wird der Schleifenkörper immer wieder ausgeführt. Vor dem ersten und nach jedem weiteren Durchlauf wird .blue[<code>condition</code>] erneut evaluiert.

```{r,  eval = F}
x <- 0
while(x < 4) {
  x <- runif(n = 1, min = 1, max = 5)
  cat(x, " ", "\n")
}
```

---
## Schleifen
### Übungsaufgaben

<ol start = "10">
    <li>Schreiben Sie eine Schleife, welche die Zahlen von 1 bis 15 aufaddiert.</li>
    <li>Erstellen Sie eine Matrix \(M\) mit folgender Gestalt:</li>
    $$M=\begin{pmatrix}
        1 & 4 & 7 & 10 & 13\\
        2 & 5 & 8 & 11 & 14\\
        3 & 6 & 9 & 12 & 15\\
      \end{pmatrix}$$
    <ul>
      <li>Schreiben Sie eine Schleife, welche für jede Spalte die Spaltensumme berechnet und ausgibt.</li>
    </ul>
    <li>Mit \(\text{rnorm}(1)\) ziehen wir eine Zufallszahl aus der Standardnormalverteilung (in der Konsole ausprobieren!). Schreiben Sie eine Schleife, welche solange ausgeführt wird, bis ein Wert gezogen wird, der größer als 1 ist. Geben Sie in jedem Durchlauf die gezogene Zahl mit \(cat(x, "\n")\) aus. (Hinweis: \(\text{\n}\) steht für einen Zeilenumbruch)</li>
</ol>

---
## Funktionen
### Funktionen definieren

Viele Funktionen habt ihr schon kennengelernt: `length()`, `sum()`, `min()`, `data.frame()`

Eigene Funktionen werden wie folgt geschrieben:

.font80[
```{r, eval = F}
name.der.funktion <- function(arg1, arg2, ...) {
  # Funktionskörper
  return(obj)
}
```
]
.blue[<code>Beispiel</code>]: Summe zweier objekte 

.font80[
```{r, eval = T}
summe <- function(x, y) {
  return(x + y)
} 
# Nachdem die Funktion definiert (und entsprechend ausgeführt) wurde, 
# kann man die Funktion direkt nutzen:
summe(x = 1, y = 3)
```
]

---
## Schleifen
###  Standardwerte der Argumente

In der Definition einer Funktion können auch Standardwerte der Argumente festgelegt werden. Dadurch kommt es zu keiner Fehlermeldung wegen fehlender Argumente.

.font80[
```{r}
summe <- function(x = 1, y = 3) {
  return(x + y)
} 
summe()
```
]

#### Environments

Beachtet, dass alle Objekte, welche innerhalb einer Funktion definiert wurden, außerhalb dieser Funktion nicht verfügbar sind! Außer man gibt deren Inhalt zurück:

.font80[
```{r, eval = FALSE}
internal.ops <- function() {
  int.x <- 5
  int.y <- 10
} 

internal.ops() # int.x un int.y sind nicht in Environment Fenster zu sehen
int.x          # Fehler!
```
]

---
## Schleifen
### Übungsaufgaben


<ol start = "13">
    <li>Die Dichte der Standardnormalverteilung lautet</li>
    $$\frac{1}{\sqrt{2\pi}} e^{-\frac{x^2}{2}}$$
     <ul>
      <li>Schreiben Sie eine Funktion `stdnv`, welche die Dichte von `x` berechnet und zurückgibt.</li>
      <ul>
        <li><b>Hinweis:</b> <code>?exp</code>, <code>?pi</code></li>
        <li><b>Hinweis:</b> Wenn die Funktion korrekt ist, sollten <code>stdnv(x)</code> und <code>dnorm(x)</code> die gleichen Ergebnisse liefern.</li>
      </ul>
    </ul>
</ol>


---
## Schleifen
### Übungsaufgaben

<ol start = "14">
    <li>Schreiben Sie eine Funktion, welche die Argumente <code>z</code> sowie <code>opt</code> erwartet. Im Funktionskörper soll mit einer If-Anweisung gesteuert werden, welche Operation auf <code>z</code> ausgeführt werden soll:</li>
    <ul>
    <li>
    <i>WENN opt gleich "add" ist, DANN addiere die Elemente von <code>z</code>, WENN <code>opt</code> gleich "mult" ist, dann multipliziere die Elemente von <code>z</code>, andernfalls führe keine Operation aus.</i></li>
    <li>Am Ende soll die Funktion das jeweilige Ergebnis wiedergeben.</li>
    </ul>
    <li>Schreiben Sie eine Funktion, die den MSE (mean squared error) von zwei Vektoren <code>y</code> und <code>yhat</code> (die Argumente) berechnet. Der MSE is definiert als \(\displaystyle \frac{1}{n}\sum_{i=1}^n (\hat{Y}_i - Y_i)^2\). Testen Sie Ihre Funktion anhand der beiden Vektoren \(y = {2, 4, 2, 5, 7}\) und \(\hat{y}= {2.3, 3.5, 2.1, 5.5, 7.6}\) (das Ergebnis sollte 0.192 lauten).</li>
</ol>

---
## R Pakete
### Pakete allgemein

<br></br>
Die Erweiterbarkeit von R ist eine seiner Stärken. Jeder kann eigene Pakete entwickeln und sie den anderen Usern zur Verfügung stellen.

[CRAN](https://cran.r-project.org/) (Comprehensive R Archive Network) ist ein verteiltes Archiv, in dem Pakete gesammelt und der breiten Öffentlichkeit zugängig gemacht werden. 

Wer sich schon etwas mit R auskennt und sich für die Entwicklung von Paketen interessiert, dem ist das Buch  [R Packages](http://r-pkgs.had.co.nz/) von Hadley Wickham zu empfehlen.

---
## R Pakete
### Pakete installieren updaten und entfernen

.font90[
Das wichtigste (und standardmäßige) *Repository* ist der CRAN Server von RStudio.

Weitere CRAN Server: 
- https://cloud.r-project.org/ 
- https://cran.uni-muenster.de/ 

Dort findet man die neuesten, stabilen Versionen von Paketen. Pakete auf CRAN müssen zudem bestimmte Anforderungen erfüllen.

RStudio stellt alles zur Verfügung um die eigene Paket-Bibliothek zu verwalten.

Sollte man Pakete doch "per Hand" managen gibt es die Funktionen `install.packages()`, `update.packages()` und `remove.packages()`.

```{r, eval = FALSE}
install.packages("quantmod")        # ein Paket mit Methoden zur Analyse von Finanzdaten
update.packages()
remove.packages(pkgs = "quantmod")
```
]















