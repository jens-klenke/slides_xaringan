---
title: "R Vorkurs"
subtitle: "Teil 3"
author: "Martin Arnold & Jens Klenke"
date: "28.10 - 30.10.2020"
output:
  xaringan::moon_reader:
    css: ["default", "assets/sydney-fonts.css", "assets/sydney.css"]
    self_contained: true # if true, fonts will be stored locally
    seal: true # show a title slide with YAML information
    includes:
      in_header: "assets/mathjax-equation-numbers.html"
    nature:
      beforeInit: ["assets/remark-zoom.js", "https://platform.twitter.com/widgets.js"]
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      ratio: '16:9' #alternatives '16:9' or '4:3' or others e.g. 13:9
      navigation:
        scroll: true #disable slide transitions by scrolling
---
class: inverse
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = T, small = T)

options(htmltools.dir.version = FALSE)
options(servr.daemon = TRUE)
options(servr.interval = 0.5)

#xaringan::inf_mr()

#### required packages ####
# packages
suppressWarnings(source(here::here('00_packages/packages.R')))
```


```{r, load_refs, echo=FALSE, cache=FALSE, warning = FALSE, message = TRUE}
library(RefManageR)
BibOptions(check.entries = FALSE, 
           bib.style = "authoryear", 
           cite.style = 'authoryear', 
           style = "markdown",
           hyperlink = FALSE, 
           dashed = FALSE)
myBib <- ReadBib("assets/example.bib", check = FALSE)

```

# Überischt 

<br></br>

1. Verteilungen und Zufallszahlen
2. Grafiken
3. Lineare Regression

---
## Verteilungen und Zufallszahlen
### Verteilungen

R kennt standardmäßig viele diskrete Verteilungen, z.B.
.font80[
- Binomialverteilung (`binom`)
- Geometrische Verteilung (`geom`)
- Hypergeometrische Verteilung (`hyper`)
- Poisson-Verteilung (`pois`)
- ...

...sowie stetige Verteilungen:

- Normalverteilung (`norm`)
- t-Verteilung (`t`)
- Chi-Quadrat-Verteilung (`chisq`)
- F-Verteilung (`f`)
- Gleichverteilung (`unif`)
- ...
]
---
## Verteilungen 
### Verteilungen - Funktionen

.font90[
Für jede Verteilung stehen hierbei 4 klassische Funktionen zur Verfügung:

- Berechnung von Punktwahrscheinlichkeiten/-dichten $\Rightarrow$ Präfix .blue[d] (.blue[d]ensity)
- Werte der Verteilungsfunktion $\Rightarrow$ Präfix .green[p] (.green[p]robability)
- Berechnen von Quantilen $\Rightarrow$ Präfix .red[q] (.red[q]uantile)
- Erzeugen von 'Zufallszahlen' $\Rightarrow$ Präfix .orange[r] (.orange[r]andom)

$\Longrightarrow$ Name der Funktion = Präfix + Verteilungskürzel (siehe vorherige Folie)

Beispiel: 

- Quantil der Normalverteilung: .red[q] + norm = `qnorm()`
- Verteilungsfunktion der Binomialverteilung: .green[p] + binom = `pbinom()`
- etc.
]

---
## Verteilungen 
### Beispiel - Chi-Quadrat-Verteilung


```{r, echo = F, fig.height = 8, fig.asp = 0.5}
par(mar=c(5.1, 4.1, 0, 2.1))
plot(seq(0, 50, 0.01),dchisq(seq(0, 50, 0.01), df = 10), type = 'l', xlab = "x", ylab = "f(x)")
lines(c(12, 12),c(-2, dchisq(12, 10)), col = "red", lwd = 2)
lines(c(-2, 12),rep(dchisq(12, 10), 2), col = "red", lwd = 2)
```

```{r}
dchisq(12, df = 10)  # Dichte an der Stelle x=12
```

---
## Verteilungen 
### Beispiel - Chi-Quadrat-Verteilung - Fortsetzung

.font90[
Analog erhalten wir für die gleiche Verteilung einen bestimmten Wert der Verteilungsfunktion...

```{r}
pchisq(8, df = 10)  # Wert der Verteilungsfunktion an der Stelle x=8
```

...ein bestimmtes Quantil

```{r}
qchisq(0.5, df = 10)  # 0.5-Quantil der Verteilung
```

...sowie Zufallszahlen

```{r}
rchisq(5, df = 10)  # 5 chi^2-verteilte Zufallszahlen
```
]

---
## Verteilungen 
### Seeds

.font80[
Wiederholen wir den Code von gerade, bekommen wir (wie erwartet) andere Zahlen

```{r}
rchisq(5, df = 10)
```

Manchmal erscheint es aber sinnvoll, Ergebnisse reproduzierbar zu machen. Dann bietet es sich an, einen sog. *seed* zu benutzen. Damit können an mehreren Rechnern die selben Zufallszahlen erzeugt werden.

```{r}
set.seed(385)
rchisq(5, df = 10)
```

```{r}
set.seed(385)
rchisq(5, df = 10)
```

Welchen seed man benutzt ist unerheblich, Hauptsache man benutzt denselben.
]

---
## Verteilungen 
### <code>sample()</code>

Neben der Erzeugung von Zufallszahlen aus vordefinierten Verteilungen, kann man auch 'eigene' Zufallsexperimente durchführen

```{r}
# Beispiel Münzwurf:

# Mögliche Ergebnisse definieren
K_Z <- c('Kopf', 'Zahl')

# Fünfmaliger Wurf einer fairen Münze
sample(K_Z, size = 5, replace = TRUE)

# Fünfmaliger Wurf einer unfairen Münze
sample(K_Z, size = 5, replace = TRUE, prob = c(0.8, 0.2))
```

---
## Verteilungen 
### Übungsaufgaben

.font90[
1. Sei $X\sim t(5)$. Berechnen Sie $P(X<6)$, $P(3<X\leq7)$ und $P(X>4)$.
2. Berechnen Sie das 0.95-Quantil einer $F(4,5)$-verteilten Zufallsvariable.
3. Berechnen Sie die Wahrscheinlichkeit dafür, den Jackpot im Lotto zu gewinnen (d.h. 6 Richtige aus 49). Vernachlässigen Sie bei Ihrer Berechnung Zusatz- oder Superzahlen (*Hinweis*: Benutzen Sie die hypergeometrische Verteilung).
4. Erzeugen Sie 20 $\chi^2(5)$ -verteilte Zufallszahlen ohne (!) dabei die `rchisq()`-Funktion zu benutzen 
(*Hinweis*: $\chi^2(n)=\sum_{i=1}^n Z_i^2$ mit $Z_i\sim\mathcal{N}(0,1)$ für alle $i=1,...,n$).
5. Ziehen Sie 10-mal standardnormalverteilte Zufallszahlen vom Umfang $n = 10000$ und berechnen Sie für jeden Durchlauf das arithmetische Mittel. Schauen Sie sich danach alle 10 Mittelwerte an. Was fällt Ihnen auf? Zusatz: Führen Sie dieselbe Aufgabe mit $X \sim t(1)$-verteilten Zufallszahlen (sog. Cauchy-Verteilung) durch. Was fällt Ihnen nun auf? Können Sie sich das Ergebnis erklären? Schauen Sie sich ggf. den Wikipedia-Eintrag zur [Cauchy-Verteilung](https://en.wikipedia.org/wiki/Cauchy_distribution) an.
6. Zusatz: Verifizieren Sie, dass das Integral über die Dichtefunktion einer $\chi^2(15)$-verteilten Zufallsvariable 1 ist. (Zum Integrieren in R können Sie `integrate()` benutzen.)
]

---
## Grafiken
### Basic Plot

Mit R ist es sehr leicht Grafiken zu erstellen, z.B. einen einfachen *Scatterplot* ...

```{r, echo = -1, fig.height = 1, fig.asp = 0.55}
set.seed(385)
plot(rnorm(10))
```

---
## Grafiken
### Basic Plot

...oder einen Linienplot in roter Farbe

```{r, echo = -1, fig.asp = 0.55}
set.seed(385)
plot(rnorm(10), type = 'l', col = 'red')
```

---
## Grafiken
### Cosmetics

Neben Parametern wie `col` können auch noch viele weitere kosmetische Dinge im Plot angepasst werden, z.B.:

- `xlab`/`ylab`: Beschriftung x- bzw y-Achse
- `xlim`/`ylim`: Darzustellender Bereich von x- bzw. y-Achse
- `main`/`sub`: Titel/Untertitel der Grafik
- `pch`: Darstellung von Punkten in einer Grafik (Kreis, Quadrat, etc.)
- `lty`/`lwd`: Darstellung (durchgezogen, gestrichelt, etc.) und Breite von Linien in einer Grafik
- uvm. (siehe `?par`)

---
## Grafiken
### Mehrere Grafiken

Will man mehrere Grafiken in einem Fenster darstellen, kann man dies über den Parameter `mfrow` machen

```{r, fig.asp=0.3, echo = -1}
par(mar = c(2.1, 4.1, 0, 2.1))
par(mfrow = c(1, 2))  # Zwei Plots in einer Zeile (bzw. über zwei Spalten)
plot(1:10, xlab = 'x', ylab = 'y')
plot(1:10, xlab = 'x', ylab = 'y', type = 'l')
```

Man beachte, dass dies eine globale Einstellung ist. Will man also wieder zum ursprünglichen Set-Up zurück, sollte man es über `dev.off()` zurücksetzen.

---
## Grafiken
### Weitere Grafikenformen
.font60[
- `hist()`
- `boxplot()`
- `barplot()`
- `pie()`
]

.font80[
Beispiel:

```{r, fig.asp = 0.55, echo = -1}
# par(mar = c(2.1, 4.1, 0, 2.1))
hist(mtcars$mpg, breaks = 5, freq = F, main = '', xlab = 'Miles per gallon')
```
]

---
## Grafiken
### Funktionen die grafische Elemente hinzufügen

Es gibt auch Funktionen, die eine bestehende Grafik voraussetzen, bspw.

- `lines()`
- `points()`
- `abline()`
- `legend()`
- `text()`
- `arrows()`

Bis auf `abline()` erwarten alle Funktionen X- und Y-Koordinaten.

---
## Grafiken
### Funktionen die grafische Elemente hinzufügen - Beispiel

```{r, fig.align='center', echo = -1, fig.asp = 0.45}
par(mar = c(4.1, 4.1, 2, 2.1))
hist(rnorm(10000), freq = F, ylim = c(0, 0.5), xlab = '', 
     main = 'Empirical vs. theoretical')
x <- seq(-5, 5, 0.01)
y <- dnorm(x)
lines(x, y, col = 'red')
```

---
## Grafiken
### Übungsaufgaben

```{r, fig.asp = 0.45}
set.seed(385)
results <- rnorm(1000, mean = 100, sd = 15)
```

.font90[
1. Kopieren Sie obigen Code und nehmen Sie an, dass dieser eine IQ-Testreihe mit 1000 Probanden simuliert. Zeichnen Sie ein Histogram der Ergebnisse. Geben Sie Ihrem Plot anschließend eine passende Überschrift sowie passende Achsenbeschriftungen. Spezifieren Sie darüber hinaus den Bereich von X- und Y-Achse auf $[40,160]$ bzw. $[0,0.03]$.

2. Hinterlegen Sie dem Plot die, dem IQ zugrundeliegende, theoretische Dichtefunktion, d.h. eine Normalverteilung mit $\mu=100$ und $\sigma=15$. Wählen Sie als Zeichenfarbe rot und machen Sie die einzuzeichnende Linie etwas breiter.

3. Zeichnen Sie einen Punkt in Form eines Dreiecks an das Maximum der theoretischen Dichte. Wählen Sie als Farbe blau.

4. Kennzeichnen Sie sowohl das 0.025- als auch das 0.975-Quantil der theoretischen Dichte, in dem Sie Vertikalen an diesen Punkten einzeichnen. Wählen Sie als Farbe grün.
]

---
## Lineare Regression

### Modell

<!--Hauptaufgabe der ?konometrie ist es, ?konomische Zusammenh?nge zu quantifizieren. Das Herzst?ck dabei bildet die Regressionsanalyse.-->
.font80[
Einfaches (univariates) lineares Regressionsmodell:

$$Y_t=\beta_0+\beta_1 X_t+u_t,\quad t=1,\ldots,T$$
  
mit 

+ $Y_t$ - Regressand (zu erklärende Variable),
+ $X_t$ - Regressor (erklärende Variable),
+ $u_t$ - Fehlerterm.

über z.B. OLS können wir dann die geschätzten Koeffizienten $\widehat{\beta_0}$ und $\widehat{\beta_1}$ erhalten.
  
Beispiel:

Im Datensatz **mtcars** sind etliche Informationen zu verschiedenen Automodellen hinterlegt. Wir vermuten nun, dass die Reichweite eines Autos (*mpg*) davon abhängt, wie schwer es ist (*wt*). D.h. wir haben folgendes geschätztes Modell:

$$\widehat{mpg_t}=\widehat{\beta_0}+\widehat{\beta_1}wt_t$$ 

(Welche Richtung des Zusammenhangs vermuten Sie?)
]

---
## Lineare Regression
### Parameterschätzung
<br></br>

Einfache lineare Regression über `lm()` (= linear model)

```{r}
model <- lm(mpg ~ wt, data = mtcars)
```

Die Ergebnisse werden in einer Liste gespeichert

```{r}
names(model)
```

---
## Lineare Regression
### Regressionsoutput

Einen kompakten Überblick über die wichtigsten Informationen erhält man auch mit `summary()`

.font80[
```{r}
summary(model)
```
]

---
## Lineare Regression
### Punktewolke und Regressionslinie

Grafisch sieht das Ganze dann so aus:

```{r, echo=-1, fig.asp=0.6, fig.align='center'}
#par(mar=c(5.1, 4.1, 0, 2.1))
plot(mtcars$wt, mtcars$mpg, xlab = 'Weight', ylab = 'Miles per gallon')
abline(model, col = 'red')
```

---
## Lineare Regression
### Vorhersage

<br></br>

Haben wir das Regressionsmodell geschätzt, können wir Vorhersagen treffen. Nehmen wir an, dass ein neues Auto mit einem Gewicht von $X_{new}=3$ (in 1000 lbs) auf den Markt kommt. Was für eine Reichweite wird dieses dann in etwa haben?

```{r}
new_weight <- data.frame(wt = 3)
predict(model, newdata = new_weight)
```

---
## Lineare Regression
### Dummy-Variablen/Regression ohne Achsenabschnitt

.font80[
Dummyvariablen (hier Getriebeart *am* mit Automatik = 0, Manuell = 1) können über die Funktion `factor()` als zusätzlicher Regressor mitaufgenommen werden.

```{r}
model_wd <- lm(mpg ~ wt + factor(am), data = mtcars)
model_wd$coefficients
```
   
(Wie sind die Koeffizienten zu interpretieren?)

Will man eine Regression ohne Achsenabschnitt ($\beta_0$) durchführen, bedarf es einer `-1` (oder alternativ `+0`) am Ende der Regressionsformel

```{r}
model_wd_no_int <- lm(mpg ~ wt + factor(am) - 1, data = mtcars)
model_wd_no_int$coefficients
```
   
(Was hat sich an der Interpretation der Koeffizienten geändert?)
]

---
## Lineare Regression
### Übungsaufgaben

.font90[
1. Betrachten Sie im Folgenden den Datensatz **faithful**, der Daten zum Old Faithful Geysir im Yellowstone Nationalpark enthält. Sowohl die Dauer einer Eruption in Min. (`eruptions`) als auch die Wartezeit bis zur nächsten Eruption in Min. (`waiting`) sind als Variable im Datensatz verfügbar. Unterstellen Sie folgendes Regressionsmodell $$\text{waiting}_t=\beta_0+\beta_1 \text{eruptions}_t + u_t$$ und schätzen Sie die entsprechenden Parameter $\widehat{\beta_0}$, $\widehat{\beta_1}$. Zeichnen Sie anschließend eine geeignete Grafik und interpretieren Sie diese.

2. Verschaffen Sie sich mit `summary()` einen Überblick über ihr in 1.) erhaltenes Ergebnis. Interpretieren Sie die geschätzten Koeffizienten und speichern Sie anschließend das $R^2$ (*Multiple R-squared*) in der Variablen `R2` ab. (Hinweis: Schauen Sie sich die, beim Ausführen von `summary()`, ausgegebene Datenstruktur genauer an.)
3. Sie beobachten einen zusätzlichen Datenpunkt für die Dauer einer Eruption von $X_{new}=4$. Sagen Sie die entsprechende Wartezeit bis zur nächsten Eruption vorher.
<!-- 4. Betrachten Sie nun den aus den Folien bekannten Datensatz **mtcars**. Regressieren Sie die Reichweite (*mpg*) auf die Getriebeart (*am* mit Automatik = 0, Manuell = 1) und lassen Sie den Achsenabschnitt weg. Interpretieren Sie ihr Ergebnis. -->
]











